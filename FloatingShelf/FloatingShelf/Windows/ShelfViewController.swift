//
//  ShelfViewController.swift
//  FloatingShelf
//

import Cocoa
import Quartz

class ShelfViewController: NSViewController {
    
    private var shelf: Shelf
    private var gridView: ShelfGridView!
    private var actionBar: ActionBarView!
    private var dropReceiver: DropReceiver!
    
    private var items: [ShelfItem] = []
    private var selectedItems: Set<UUID> = []
    private var autoHideTimer: Timer?
    
    init(shelf: Shelf) {
        self.shelf = shelf
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func loadView() {
        let dropView = DropView(frame: NSRect(x: 0, y: 0, 
                                              width: Constants.defaultShelfWidth, 
                                              height: Constants.defaultShelfHeight))
        view = dropView
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        loadItems()
        
        // Set up drop receiver after view is loaded
        if let dropView = view as? DropView {
            dropReceiver = DropReceiver(shelfId: shelf.id)
            dropReceiver.delegate = self
            dropView.dropReceiver = dropReceiver
            dropView.registerForDraggedTypes(dropReceiver.acceptedTypes)
        }
    }
    
    // MARK: - Keyboard Events
    
    override func keyDown(with event: NSEvent) {
        // Space bar = Quick Look
        if event.keyCode == 49 && !selectedItems.isEmpty {
            showQuickLook()
        } else {
            super.keyDown(with: event)
        }
    }
    
    override var acceptsFirstResponder: Bool { true }
    
    // MARK: - UI Setup
    
    private func setupUI() {
        // Grid view for items (add first, so it's at bottom)
        gridView = ShelfGridView()
        gridView.translatesAutoresizingMaskIntoConstraints = false
        gridView.delegate = self
        view.addSubview(gridView)
        
        // Action bar at bottom (hidden by default, shows on hover)
        actionBar = ActionBarView()
        actionBar.translatesAutoresizingMaskIntoConstraints = false
        actionBar.delegate = self
        actionBar.alphaValue = 0  // Hidden initially
        view.addSubview(actionBar)
        
        // Custom title bar for borderless window (add LAST to be on top)
        let titleBar = createCustomTitleBar()
        titleBar.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(titleBar)
        
        // Layout constraints
        NSLayoutConstraint.activate([
            // Title bar at top
            titleBar.topAnchor.constraint(equalTo: view.topAnchor),
            titleBar.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            titleBar.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            titleBar.heightAnchor.constraint(equalToConstant: 28),
            
            // Grid view fills to bottom (action bar overlays)
            gridView.topAnchor.constraint(equalTo: titleBar.bottomAnchor),
            gridView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            gridView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            gridView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            
            // Action bar overlays bottom
            actionBar.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 8),
            actionBar.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -8),
            actionBar.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -8),
            actionBar.heightAnchor.constraint(equalToConstant: 36)
        ])
        
        // Set up hover tracking
        setupHoverTracking()
    }
    
    private func setupHoverTracking() {
        let trackingArea = NSTrackingArea(
            rect: .zero,
            options: [.mouseEnteredAndExited, .activeAlways, .inVisibleRect],
            owner: self,
            userInfo: nil
        )
        view.addTrackingArea(trackingArea)
    }
    
    override func mouseEntered(with event: NSEvent) {
        NSAnimationContext.runAnimationGroup { context in
            context.duration = 0.2
            actionBar.animator().alphaValue = 1
        }
    }
    
    override func mouseExited(with event: NSEvent) {
        NSAnimationContext.runAnimationGroup { context in
            context.duration = 0.2
            actionBar.animator().alphaValue = 0
        }
    }
    
    private func createCustomTitleBar() -> NSView {
        let titleBar = NSView()
        titleBar.wantsLayer = true
        
        // Apply shelf color to title bar
        let shelfColor = NSColor(hex: shelf.colorHex) ?? NSColor.systemBlue
        titleBar.layer?.backgroundColor = shelfColor.withAlphaComponent(0.9).cgColor
        
        // Close button - macOS style red circle
        let closeButton = NSButton()
        closeButton.bezelStyle = .regularSquare
        closeButton.isBordered = false
        closeButton.wantsLayer = true
        closeButton.layer?.cornerRadius = 12
        closeButton.layer?.backgroundColor = NSColor.systemRed.withAlphaComponent(0.9).cgColor
        closeButton.title = ""
        closeButton.target = self
        closeButton.action = #selector(closeWindow)
        closeButton.translatesAutoresizingMaskIntoConstraints = false
        
        let xLabel = NSTextField(labelWithString: "âœ•")
        xLabel.font = NSFont.systemFont(ofSize: 14, weight: .bold)
        xLabel.textColor = NSColor.white
        xLabel.translatesAutoresizingMaskIntoConstraints = false
        closeButton.addSubview(xLabel)
        
        // Color picker button - using NSView with click gesture for better reliability
        let colorButton = NSView()
        colorButton.wantsLayer = true
        colorButton.layer?.cornerRadius = 4
        colorButton.layer?.backgroundColor = shelfColor.cgColor
        colorButton.layer?.borderWidth = 1
        colorButton.layer?.borderColor = NSColor.white.withAlphaComponent(0.6).cgColor
        colorButton.translatesAutoresizingMaskIntoConstraints = false
        
        // Add click gesture recognizer
        let clickGesture = NSClickGestureRecognizer(target: self, action: #selector(showColorPicker))
        colorButton.addGestureRecognizer(clickGesture)
        
        // Shelf name label (editable)
        let nameField = NSTextField()
        nameField.stringValue = shelf.name
        nameField.font = NSFont.systemFont(ofSize: 11, weight: .medium)
        nameField.textColor = NSColor.white
        nameField.backgroundColor = .clear
        nameField.isBordered = false
        nameField.isEditable = true
        nameField.focusRingType = .none
        nameField.alignment = .center
        nameField.target = self
        nameField.action = #selector(shelfNameChanged(_:))
        nameField.translatesAutoresizingMaskIntoConstraints = false
        
        // Add subviews (order matters for z-index)
        titleBar.addSubview(nameField)
        titleBar.addSubview(closeButton)
        titleBar.addSubview(colorButton) // Last = on top
        
        NSLayoutConstraint.activate([
            // Close button
            closeButton.leadingAnchor.constraint(equalTo: titleBar.leadingAnchor, constant: 10),
            closeButton.centerYAnchor.constraint(equalTo: titleBar.centerYAnchor),
            closeButton.widthAnchor.constraint(equalToConstant: 24),
            closeButton.heightAnchor.constraint(equalToConstant: 24),
            
            // X centered in button
            xLabel.centerXAnchor.constraint(equalTo: closeButton.centerXAnchor),
            xLabel.centerYAnchor.constraint(equalTo: closeButton.centerYAnchor),
            
            // Color picker button (right side) - larger for easier clicking
            colorButton.trailingAnchor.constraint(equalTo: titleBar.trailingAnchor, constant: -10),
            colorButton.centerYAnchor.constraint(equalTo: titleBar.centerYAnchor),
            colorButton.widthAnchor.constraint(equalToConstant: 16),
            colorButton.heightAnchor.constraint(equalToConstant: 16),
            
            // Name field
            nameField.leadingAnchor.constraint(equalTo: closeButton.trailingAnchor, constant: 8),
            nameField.trailingAnchor.constraint(equalTo: colorButton.leadingAnchor, constant: -8),
            nameField.centerYAnchor.constraint(equalTo: titleBar.centerYAnchor)
        ])
        
        return titleBar
    }
    
    private var colorPopover: NSPopover?
    
    // Preset colors
    private let presetColors: [String] = [
        "#4A90D9", // Blue
        "#5C6BC0", // Indigo
        "#7E57C2", // Purple
        "#EC407A", // Pink
        "#EF5350", // Red
        "#FF7043", // Orange
        "#FFCA28", // Yellow
        "#66BB6A", // Green
        "#26A69A", // Teal
        "#78909C"  // Gray
    ]
    
    @objc private func showColorPicker() {
        // Close existing popover
        colorPopover?.close()
        
        // Create color palette view
        let paletteView = NSView(frame: NSRect(x: 0, y: 0, width: 160, height: 80))
        paletteView.wantsLayer = true
        
        // Create color buttons in 5x2 grid
        for (index, colorHex) in presetColors.enumerated() {
            let row = index / 5
            let col = index % 5
            
            let colorButton = NSButton(frame: NSRect(
                x: 8 + col * 30,
                y: 42 - row * 30,
                width: 26,
                height: 26
            ))
            colorButton.bezelStyle = .regularSquare
            colorButton.isBordered = false
            colorButton.wantsLayer = true
            colorButton.layer?.cornerRadius = 13
            colorButton.layer?.backgroundColor = NSColor(hex: colorHex)?.cgColor
            colorButton.tag = index
            colorButton.target = self
            colorButton.action = #selector(colorSelected(_:))
            
            // Add border for current color
            if colorHex == shelf.colorHex {
                colorButton.layer?.borderWidth = 2
                colorButton.layer?.borderColor = NSColor.white.cgColor
            }
            
            paletteView.addSubview(colorButton)
        }
        
        // Create popover
        let popover = NSPopover()
        popover.behavior = .transient
        popover.contentSize = paletteView.bounds.size
        
        let viewController = NSViewController()
        viewController.view = paletteView
        popover.contentViewController = viewController
        
        // Show in top-right of screen
        if let window = view.window {
            let colorButtonFrame = NSRect(
                x: window.frame.maxX - 30,
                y: window.frame.maxY - 20,
                width: 20,
                height: 20
            )
            popover.show(relativeTo: colorButtonFrame, of: view, preferredEdge: .maxY)
        }
        
        colorPopover = popover
    }
    
    @objc private func colorSelected(_ sender: NSButton) {
        let colorHex = presetColors[sender.tag]
        shelf.colorHex = colorHex
        ItemStore.shared.updateShelf(shelf)
        colorPopover?.close()
        
        // Refresh view
        view.subviews.forEach { $0.removeFromSuperview() }
        setupUI()
    }
    
    @objc private func shelfNameChanged(_ sender: NSTextField) {
        shelf.name = sender.stringValue
        ItemStore.shared.updateShelf(shelf)
    }
    
    @objc private func closeWindow() {
        view.window?.close()
    }
    
    // MARK: - Clipboard Support
    
    @objc func paste(_ sender: Any?) {
        pasteFromClipboard()
    }
    
    private func pasteFromClipboard() {
        let pasteboard = NSPasteboard.general
        
        do {
            let newItems = try dropReceiver.processPasteboard(pasteboard)
            
            if newItems.isEmpty {
                // No valid content in clipboard
                return
            }
            
            // Add items to store
            for item in newItems {
                ItemStore.shared.addItem(item, to: shelf.id)
            }
            
            // Reload
            items.append(contentsOf: newItems)
            gridView.reloadData(with: items)
            checkAutoHide()
            
        } catch {
            let alert = NSAlert()
            alert.messageText = "Paste Failed"
            alert.informativeText = error.localizedDescription
            alert.alertStyle = .warning
            alert.runModal()
        }
    }
    
    // MARK: - Quick Look
    
    private func showQuickLook() {
        guard !selectedItems.isEmpty else { return }
        
        if let panel = QLPreviewPanel.shared() {
            panel.makeKeyAndOrderFront(nil)
        }
    }
    
    override func acceptsPreviewPanelControl(_ panel: QLPreviewPanel!) -> Bool {
        return true
    }
    
    override func beginPreviewPanelControl(_ panel: QLPreviewPanel!) {
        panel.delegate = self
        panel.dataSource = self
    }
    
    override func endPreviewPanelControl(_ panel: QLPreviewPanel!) {
        // Nothing to clean up
    }
    
    // MARK: - Data
    
    private func loadItems() {
        items = ItemStore.shared.fetchItems(for: shelf.id)
        gridView.reloadData(with: items)
        updateActionBarState()
        checkAutoHide()
    }
    
    private func updateActionBarState() {
        actionBar.setEnabled(!selectedItems.isEmpty)
    }
    
    // MARK: - Auto-Hide
    
    private func checkAutoHide() {
        // Cancel existing timer
        autoHideTimer?.invalidate()
        autoHideTimer = nil
        
        // Only start timer if auto-hide is enabled and shelf is empty
        guard SettingsManager.shared.autoHideEnabled, items.isEmpty else { return }
        
        let delay = SettingsManager.shared.autoHideDelay
        autoHideTimer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] _ in
            self?.autoHideShelf()
        }
    }
    
    private func autoHideShelf() {
        guard let window = view.window else { return }
        
        // Fade out animation
        NSAnimationContext.runAnimationGroup({ context in
            context.duration = 0.3
            window.animator().alphaValue = 0
        }, completionHandler: { [weak self] in
            self?.closeWindow()
        })
    }
}

// MARK: - DropReceiverDelegate

extension ShelfViewController: DropReceiverDelegate {
    func dropReceiver(_ receiver: DropReceiver, didReceiveItems newItems: [ShelfItem]) {
        items.append(contentsOf: newItems)
        gridView.reloadData(with: items)
        checkAutoHide() // Cancel auto-hide if items were added
    }
    
    func dropReceiver(_ receiver: DropReceiver, didFailWithError error: Error) {
        let alert = NSAlert()
        alert.messageText = "Drop Failed"
        alert.informativeText = error.localizedDescription
        alert.alertStyle = .warning
        alert.runModal()
    }
}

// MARK: - ShelfGridViewDelegate

extension ShelfViewController: ShelfGridViewDelegate {
    func gridView(_ gridView: ShelfGridView, didSelectItems itemIds: Set<UUID>) {
        selectedItems = itemIds
        updateActionBarState()
    }
    
    func gridView(_ gridView: ShelfGridView, didDeleteItems itemIds: Set<UUID>) {
        ItemStore.shared.deleteItems(Array(itemIds))
        items.removeAll { itemIds.contains($0.id) }
        selectedItems.removeAll()
        gridView.reloadData(with: items)
        updateActionBarState()
    }
}

// MARK: - ActionBarDelegate

extension ShelfViewController: ActionBarDelegate {
    func actionBarDidRequestShare(_ actionBar: ActionBarView) {
        let selectedItemsArray = items.filter { selectedItems.contains($0.id) }
        shareItems(selectedItemsArray)
    }
    
    func actionBarDidRequestAirDrop(_ actionBar: ActionBarView) {
        let selectedItemsArray = items.filter { selectedItems.contains($0.id) }
        airDropItems(selectedItemsArray)
    }
    
    func actionBarDidRequestCopy(_ actionBar: ActionBarView) {
        let selectedItemsArray = items.filter { selectedItems.contains($0.id) }
        copyItems(selectedItemsArray)
    }
    
    func actionBarDidRequestPaste(_ actionBar: ActionBarView) {
        pasteFromClipboard()
    }
    
    func actionBarDidRequestSave(_ actionBar: ActionBarView) {
        let selectedItemsArray = items.filter { selectedItems.contains($0.id) }
        saveItems(selectedItemsArray)
    }
    
    func actionBarDidRequestDelete(_ actionBar: ActionBarView) {
        gridView(gridView, didDeleteItems: selectedItems)
    }
    
    // MARK: - Actions Implementation
    
    private func shareItems(_ items: [ShelfItem]) {
        var sharingItems: [Any] = []
        
        for item in items {
            switch item.kind {
            case .file, .promisedFile:
                if let path = item.payloadPath {
                    let storageDir = try? FileManager.default.shelfStorageDirectory()
                    let fileURL = storageDir?.appendingPathComponent(path)
                    if let url = fileURL {
                        sharingItems.append(url)
                    }
                }
            case .image:
                if let path = item.payloadPath {
                    let storageDir = try? FileManager.default.shelfStorageDirectory()
                    let fileURL = storageDir?.appendingPathComponent(path)
                    if let url = fileURL, let image = NSImage(contentsOf: url) {
                        sharingItems.append(image)
                    }
                }
            case .text, .url:
                sharingItems.append(item.displayName)
            }
        }
        
        guard !sharingItems.isEmpty else { return }
        
        let sharingPicker = NSSharingServicePicker(items: sharingItems)
        if let button = actionBar.shareButton {
            sharingPicker.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
        }
    }
    
    private func airDropItems(_ items: [ShelfItem]) {
        var sharingItems: [URL] = []
        
        for item in items {
            if let path = item.payloadPath {
                if let storageDir = try? FileManager.default.shelfStorageDirectory() {
                    let fileURL = storageDir.appendingPathComponent(path)
                    if FileManager.default.fileExists(atPath: fileURL.path) {
                        sharingItems.append(fileURL)
                    }
                }
            }
        }
        
        guard !sharingItems.isEmpty else {
            let alert = NSAlert()
            alert.messageText = "No files to share"
            alert.informativeText = "Select files to share via AirDrop."
            alert.runModal()
            return
        }
        
        // Use AirDrop service directly
        if let airDropService = NSSharingService(named: .sendViaAirDrop) {
            if airDropService.canPerform(withItems: sharingItems) {
                airDropService.perform(withItems: sharingItems)
            } else {
                let alert = NSAlert()
                alert.messageText = "AirDrop Unavailable"
                alert.informativeText = "Please enable AirDrop in Control Center or System Settings."
                alert.runModal()
            }
        }
    }
    
    private func copyItems(_ items: [ShelfItem]) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        
        var urls: [URL] = []
        var strings: [String] = []
        
        for item in items {
            switch item.kind {
            case .file, .promisedFile:
                if let path = item.payloadPath {
                    let storageDir = try? FileManager.default.shelfStorageDirectory()
                    if let fileURL = storageDir?.appendingPathComponent(path) {
                        urls.append(fileURL)
                    }
                }
            case .text, .url:
                strings.append(item.displayName)
            case .image:
                if let path = item.payloadPath {
                    let storageDir = try? FileManager.default.shelfStorageDirectory()
                    if let fileURL = storageDir?.appendingPathComponent(path) {
                        urls.append(fileURL)
                    }
                }
            }
        }
        
        var objects: [NSPasteboardWriting] = []
        if !urls.isEmpty {
            objects.append(contentsOf: urls as [NSPasteboardWriting])
        }
        if !strings.isEmpty {
            objects.append(strings.joined(separator: "\n") as NSPasteboardWriting)
        }
        
        pasteboard.writeObjects(objects)
    }
    
    private func saveItems(_ items: [ShelfItem]) {
        let savePanel = NSSavePanel()
        savePanel.canCreateDirectories = true
        savePanel.message = "Choose a location to save items"
        savePanel.prompt = "Save"
        
        savePanel.begin { [weak self] response in
            guard response == .OK, let destinationURL = savePanel.url else { return }
            self?.performSave(items, to: destinationURL)
        }
    }
    
    private func performSave(_ items: [ShelfItem], to destinationURL: URL) {
        do {
            let storageDir = try FileManager.default.shelfStorageDirectory()
            
            for item in items {
                if let path = item.payloadPath {
                    let sourceURL = storageDir.appendingPathComponent(path)
                    let targetURL = destinationURL.appendingPathComponent(item.displayName)
                    try FileManager.default.copyItem(at: sourceURL, to: targetURL)
                }
            }
        } catch {
            let alert = NSAlert()
            alert.messageText = "Save Failed"
            alert.informativeText = error.localizedDescription
            alert.alertStyle = .warning
            alert.runModal()
        }
    }
}

// MARK: - DropView

/// Custom view that implements NSDraggingDestination
class DropView: NSView {
    
    var dropReceiver: DropReceiver?
    
    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        wantsLayer = true
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        wantsLayer = true
    }
    
    override func draggingEntered(_ sender: NSDraggingInfo) -> NSDragOperation {
        return dropReceiver?.draggingEntered(sender) ?? []
    }
    
    override func draggingUpdated(_ sender: NSDraggingInfo) -> NSDragOperation {
        return dropReceiver?.draggingUpdated(sender) ?? []
    }
    
    override func performDragOperation(_ sender: NSDraggingInfo) -> Bool {
        return dropReceiver?.performDragOperation(sender) ?? false
    }
}

// MARK: - QLPreviewPanel DataSource & Delegate

extension ShelfViewController: QLPreviewPanelDataSource, QLPreviewPanelDelegate {
    
    func numberOfPreviewItems(in panel: QLPreviewPanel!) -> Int {
        return selectedItems.count
    }
    
    func previewPanel(_ panel: QLPreviewPanel!, previewItemAt index: Int) -> (any QLPreviewItem)! {
        let selectedArray = items.filter { selectedItems.contains($0.id) }
        guard index < selectedArray.count else { return nil }
        
        let item = selectedArray[index]
        
        // Get file URL
        if let payloadPath = item.payloadPath {
            do {
                let storageDir = try FileManager.default.shelfStorageDirectory()
                let fileURL = storageDir.appendingPathComponent(payloadPath)
                return fileURL as NSURL
            } catch {
                return nil
            }
        }
        
        return nil
    }
}
